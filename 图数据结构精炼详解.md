# 图数据结构精炼详解

## 一、核心概念：什么是图？

**图 = 顶点 + 边**

想象你在规划旅行：
- **顶点**：代表城市（北京、上海、广州）
- **边**：代表城市间的交通线路（高速公路、铁路）
- **权重**：距离或通行时间（北京到上海1200公里）
- **度**：某个城市有多少条直达线路
- **路径**：从北京到广州的路线规划
- **环**：绕一圈回到起点的路线

---

## 二、图的分类：一张图能有多少种形态？

### 📊 分类总览表

| 分类维度 | 类型 | 特点 | 生活实例 |
|---------|------|------|---------|
| **方向** | 无向图 | 边没有方向，双向可达 | 微信好友（互为好友） |
| | 有向图 | 边有方向，单向连接 | Twitter关注（单向） |
| **权重** | 无权图 | 只关心连不连通 | 人际关系图 |
| | 带权图 | 边有数值属性 | 地图导航（距离、时间） |
| **连通性** | 连通图 | 任意两点可达 | 完整的交通网络 |
| | 非连通图 | 存在孤立区域 | 断裂的桥梁导致无法到达 |
| **密度** | 稀疏图 | 边相对较少 | 乡村公路网 |
| | 稠密图 | 边相对较多 | 城市地铁网 |
| **特殊** | 树 | 无环连通图 | 公司组织架构 |
| | DAG | 有向无环图 | 任务依赖关系 |
| | 完全图 | 每对顶点都相连 | 微信群（所有人互加好友） |

---

## 三、图的存储：三种表示方法对比

### 🎯 选择指南
- **顶点少、边多** → 邻接矩阵
- **顶点多、边少** → 邻接表
- **只关心边本身** → 边列表

### 📋 三种方法详细对比

| 特性 | 邻接矩阵 | 邻接表 | 边列表 |
|------|---------|--------|--------|
| **空间复杂度** | O(V²) | O(V+E) | O(E) |
| **检查边是否存在** | O(1) | O(degree) | O(E) |
| **添加边** | O(1) | O(1) | O(1) |
| **删除边** | O(1) | O(degree) | O(E) |
| **遍历所有边** | O(V²) | O(V+E) | O(E) |
| **适用场景** | 稠密图、频繁查询 | 稀疏图、节省空间 | 算法竞赛、边操作 |

### 💻 代码实现示例

```python
# 方式1：邻接矩阵（二维数组）
# 适合：快速判断两点是否相连
# 缺点：占用空间大
adj_matrix = [
    [0, 1, 1, 0],  # A连接B、C
    [1, 0, 1, 1],  # B连接A、C、D
    [1, 1, 0, 1],  # C连接A、B、D
    [0, 1, 1, 0]   # D连接B、C
]

# 方式2：邻接表（字典+列表）
# 适合：存储稀疏图，节省空间
# 缺点：检查边需要遍历
adj_list = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': ['D'],
    'D': []
}

# 方式3：边列表（三元组列表）
# 适合：需要遍历所有边的算法
# 缺点：查找特定边慢
edge_list = [
    ('A', 'B', 5),  # (起点, 终点, 权重)
    ('B', 'C', 3),
    ('C', 'D', 2)
]
```

---

## 四、核心算法：图的灵魂

### 🗺️ 1. 深度优先搜索（DFS）- 不撞南墙不回头
**思想**：沿着一条路走到黑，走不通再回头
**比喻**：走迷宫时一直靠右墙走
**用途**：拓扑排序、检测环、路径查找
**实现**：栈或递归

```python
def dfs(graph, start):
    visited = set()
    def helper(node):
        visited.add(node)
        print(node)  # 处理节点
        for neighbor in graph[node]:
            if neighbor not in visited:
                helper(neighbor)
    helper(start)
```

### 🌊 2. 广度优先搜索（BFS）- 层层推进
**思想**：先访问离起点近的，再访问远的
**比喻**：水波扩散，层层推进
**用途**：最短路径（无权图）、社交网络"三度人脉"
**实现**：队列

```python
from collections import deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        print(node)  # 处理节点
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 📏 3. 最短路径算法

| 算法 | 适用场景 | 时间复杂度 | 关键思想 |
|------|---------|-----------|---------|
| **Dijkstra** | 带权图、无负权 | O(ElogV) | 贪心，每次选最近的 |
| **Bellman-Ford** | 带权图、可负权 | O(VE) | 动态规划，松弛所有边 |
| **Floyd-Warshall** | 所有点对最短路径 | O(V³) | 动态规划，中间点枚举 |
| **A*** | 有启发信息的图 | 取决于启发函数 | 贪心+启发式搜索 |

### 🌲 4. 最小生成树（MST）

**问题**：用最小的成本连接所有顶点
**应用**：设计电路板、规划交通网络

| 算法 | 时间复杂度 | 特点 |
|------|-----------|------|
| **Prim** | O(ElogV) | 从点出发，逐步扩展 |
| **Kruskal** | O(ElogE) | 从边出发，按权重排序 |

---

## 五、应用场景：图能做什么？

### 🌐 1. 社交网络
- **问题**：推荐好友、影响力分析
- **建模**：用户是顶点，关注关系是边
- **算法**：BFS找最短连接路径

### 🗺️ 2. 地图导航
- **问题**：最短路线、最少时间
- **建模**：路口是顶点，道路是边，距离是权重
- **算法**：Dijkstra或A*

### 🔧 3. 任务调度
- **问题**：编译顺序、项目排期
- **建模**：任务是顶点，依赖关系是有向边
- **算法**：拓扑排序（DAG）

### 🕸️ 4. 网页排名（PageRank）
- **问题**：评估网页重要性
- **建模**：网页是顶点，超链接是有向边
- **算法**：随机游走+迭代计算

### 🧬 5. 生物信息学
- **问题**：蛋白质相互作用、基因调控网络
- **建模**：分子是顶点，相互作用是边
- **算法**：网络流、社区发现

---

## 六、实战选择指南

### 🤔 如何为你的问题选择合适的图结构？

**步骤1：明确问题类型**
- 关系是否对称？→ 无向/有向
- 是否需要数值属性？→ 无权/带权
- 数据规模多大？→ 稀疏/稠密

**步骤2：选择存储方式**
- 小规模（<1000顶点）→ 邻接矩阵（简单直观）
- 大规模、边少 → 邻接表（节省空间）
- 算法竞赛 → 边列表（灵活）

**步骤3：选择算法**
- 找任意路径 → DFS
- 找最短路径（无权）→ BFS
- 找最短路径（带权）→ Dijkstra
- 找最小连接成本 → Prim/Kruskal

---

## 七、总结：图的核心要点

### ✅ 必须掌握
1. **三种表示**：邻接矩阵、邻接表、边列表的优缺点
2. **两种遍历**：DFS和BFS的思想及实现
3. **最短路径**：Dijkstra算法的应用场景
4. **最小生成树**：解决连接成本最小化问题

### 🎯 设计直觉
- **图是关系的数学抽象**：任何"多对多"关系都可以建模为图
- **空间换时间**：邻接矩阵查询快但费空间，邻接表省空间但查询慢
- **问题驱动算法**：根据具体需求（最短、最小、连通）选择算法

---

## 附录：快速参考

### 时间复杂度速查
- **DFS/BFS**：O(V + E)
- **Dijkstra**：O(ElogV)
- **Prim/Kruskal**：O(ElogV)
- **Floyd-Warshall**：O(V³)

### 空间复杂度速查
- **邻接矩阵**：O(V²)
- **邻接表**：O(V + E)
- **DFS递归栈**：O(V)
- **BFS队列**：O(V)

---

**学习建议**：从邻接表和BFS/DFS开始，通过实际项目（如最短路径计算器、社交网络分析）加深理解，再逐步学习高级算法。